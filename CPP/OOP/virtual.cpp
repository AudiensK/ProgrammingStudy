// 在 C++ 里，虚函数是实现运行时多态的重要机制，它允许通过基类指针或引用调用派生类的函数。

// 虚函数的定义需要在函数返回类型前加上virtual关键字，而且只能是类的成员函数。

// 虚函数的实现依赖于虚函数表（vtable）和虚表指针（vptr）：\
    虚函数表（vtable）：\
    每个包含虚函数的类都会有一个虚函数表，它是一个存储函数指针的数组，里面记录了该类各个虚函数的入口地址。\
    虚表指针（vptr）：\
    虚函数的对象都会有一个虚表指针，这个指针在对象创建时被初始化，指向所属类的虚函数表。\
当调用虚函数时，程序会先通过对象的虚表指针找到对应的虚函数表，然后在虚函数表中查找并调用相应的函数。\
这种间接调用机制使得程序能够在运行时动态地选择函数。

// 虚函数的关键特性\
1.重写（Override）：\
    派生类中重写的虚函数必须与基类虚函数的函数签名（返回类型、参数列表、常量性）保持一致。\
    不过，当返回类型是基类指针 / 引用时，派生类可以返回派生类的指针 / 引用，这被称为协变返回类型。\
2.纯虚函数与抽象类：\
    纯虚函数是在声明时初始化为=0的虚函数，包含纯虚函数的类被称为抽象类，抽象类不能实例化。\
3.虚析构函数：\
    在基类的析构函数前加上virtual关键字定义虚析构函数，可以确保通过基类指针删除派生类对象时，\
    能正确调用派生类的析构函数，防止内存泄漏。

// 应用场景\
实现多态接口：在设计框架或者库时，常常会定义抽象基类作为接口，让派生类去实现具体的功能。\
模板方法模式：在基类中定义算法的骨架，将一些步骤延迟到派生类中实现。\
事件处理系统：通过基类定义事件处理器接口，派生类实现具体的事件响应逻辑。\

// 注意事项\
性能开销：虚函数的调用需要通过虚函数表进行间接访问，这会带来一定的性能开销，不过在大多数情况下这种开销是可以接受的。\
构造函数与虚函数：在构造函数和析构函数中调用虚函数时，不会发生动态绑定，此时调用的是当前类的函数版本。\
默认参数与虚函数：虚函数的默认参数是在编译时确定的，所以调用时会使用基类中定义的默认参数，而不是派生类的。

// 纯虚函数（Pure Virtual Function）是一种特殊的虚函数，它在基类中声明但不提供实现，\
而是强制派生类必须实现该函数。纯虚函数的主要作用是定义接口、实现多态和创建抽象基类。
// 特点：\
    基类中不提供纯虚函数的实现（但可以提供，需显式调用）。\
    包含纯虚函数的类称为抽象基类，无法实例化。\
    派生类必须实现所有纯虚函数才能实例化，否则仍为抽象类。
    
// 纯虚函数的主要用途:\
    定义接口规范:纯虚函数可以定义一组必须由派生类实现的方法，形成统一的接口规范。这在框架设计中尤为常见。\
    实现多态行为:通过纯虚函数，可以在基类指针或引用上调用派生类的具体实现，实现运行时多态。\
    创建抽象基类:抽象基类无法实例化，只能作为接口被继承。这有助于强制遵循设计约束。

#include <iostream>

class Shape // 抽象类
// 包含纯虚函数的类就是抽象类，抽象类无法实例化，但是可以定义指针
// 基类有多个纯虚函数，派生类如果未实现基类所有纯虚函数（不包括纯虚析构函数），那么该派生类仍为抽象类。
// 多级继承中，只要有一个派生类实现了基类所有纯虚函数，该子类派生的所有子类都不会继承纯虚函数，也就不是抽象类。
{
public:
    Shape() {} // 构造函数不能成为虚函数

    // virtual ~Shape() { std::cout << "调用virtual ~Shape()" << std::endl; } // 虚析构函数
    // 在多级继承结构中，只需要基类的析构函数被声明为虚析构函数，\
    就可以确保通过基类指针删除最底层派生类对象时，整个析构链（从最底层到基类）被正确调用。\
    中间层类的析构函数不需要显式声明为virtual，因为虚析构特性会自动传递到所有派生类。

    // 析构函数也可以是纯虚函数\
    即使基类的析构函数被声明为纯虚函数，也必须在类外提供其定义。\
    否则，派生类对象析构时无法调用基类析构函数，导致链接错误。\
    包含纯虚析构函数的类仍为抽象类，无法实例化，但派生类必须实现所有 其他 纯虚函数才能实例化。\
    派生类无需显式 “实现” 纯虚析构函数，只需定义自己的析构函数。
    virtual ~Shape() = 0; // 必须在类外提供定义
    // 纯虚析构函数是 C++ 中的一种特殊语法，主要用于强制基类成为抽象类，同时确保基类的析构逻辑被正确调用。

    // virtual double area() { return 0; } // 虚函数

    virtual double area() = 0; // 纯虚函数

};

Shape::~Shape() // 纯虚析构函数必须在类外提供定义，否则会链接错误。
{
    std::cout << "调用virtual ~Shape()" << std::endl;
}

class Circle : public Shape
{
public:
    ~Circle() { std::cout << "调用~Circle()" << std::endl; } // 隐式虚函数
    // override 是一个特殊标识符（C++11），用于显式声明派生类中的成员函数重写了基类的虚函数。\
    它的主要作用是提高代码的可读性、安全性和可维护性。\
    当在派生类的函数声明中使用 override 时，编译器会检查以下两点：\
        基类中是否存在同名虚函数\
        函数签名（参数类型、返回类型、常量性等）是否严格匹配\
    如果不满足上述条件，编译器会报错，避免因疏忽导致的函数未重写问题。
    double area() override { return PI * r * r; } // 重写基类虚函数
private:
    double r = 4.0;
protected:
    const double PI = 3.14;
};

class Rectangle : public Shape
{
public:
    ~Rectangle() { std::cout << "调用~Rectangle()" << std::endl; } // 隐式虚函数
    double area() override { return w * h; } // 重写基类虚函数
private:
    double w = 1.0, h = 1.0;
};

class Oval : public Circle
{
public:
    ~Oval() { std::cout << "调用~Oval()" << std::endl; }
    // 虚函数特性会自动传递，只要基类的函数是虚函数，\
    其派生类中具有相同函数签名（返回类型、参数列表、常量性）的函数都会隐式成为虚函数。
    double area() // override
    {
        return l * s * PI;
    }
private:
    double l = 5.0, s = 4.0; 
};

int main(void)
{
    Shape* s1 = new Circle;
    Shape* s2 = new Rectangle();
    std::cout << s1->area() << std::endl; // 输出Circle::area()
    std::cout << s2->area() << std::endl; // 输出Rectangle::area()

    // 使用虚析构函数，基类指针可以正确调用派生类的析构函数，避免内存泄漏
    // 如果没有虚析构，释放内存时只会调用当前指针类型的析构函数,\
    释放内存时，由于按照父类的大小去释放，实际上子类对象申请了更大的空间，所以子类多出的部分内存未被释放
    delete s1; s1 = nullptr;
    delete s2; s2 = nullptr;

    // 包含纯虚函数的类称为抽象基类，无法实例化。
    // Shape s3;
    // Shape* s3 = new Shape();

    Shape* s4 = new Oval;
    std::cout << s4->area() << std::endl;
    delete s4; s4 = nullptr;
    // 二级派生类中area()仍是虚函数
    Circle* s5 = new Oval;
    std::cout << s5->area() << std::endl;
    delete s5; s5 = nullptr;

    return 0;
}